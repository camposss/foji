{{ .NotNeededIfNoAuth -}}
// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.
{{ $packageName := "http" }}
package {{$packageName}}

import (
    "bytes"
    "strings"
    "encoding/base64"

	"github.com/bir/iken/fastutil"
    "github.com/valyala/fasthttp"
)

// HttpAuthFunc is the signature of a function used to authenticate an http request.
// Given a request, it returns the authenticated user.  If unable to authenticate the
// request it returns an error.
type HttpAuthFunc = func(ctx *fasthttp.RequestCtx)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

// Authenticator takes a key (for example a bearer token) and returns the authenticated user.
type Authenticator = func(key string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)

{{- if .HasBasicAuth }}

// BasicAuthenticator takes a user/pass pair and returns the authenticated user.
type BasicAuthenticator = func(user,pass string) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error)
{{- end}}

{{- if .HasAuthorization }}

// Authorizer is given an authenticated User and a list of scopes to validate.
type Authorizer = func(user *{{ $.CheckPackage $.Params.Auth $packageName }}, scopes ...string ) (error)
{{- end}}

{{- if or .HasBasicAuth .HasBearerAuth }}
var (
{{- if .HasBasicAuth }}
    basicAuthPrefix = []byte("Basic ")
{{- end}}
{{- if .HasBearerAuth }}
    bearerAuthPrefix = []byte("Bearer ")
{{- end}}
)
{{- end}}

{{- range $security, $value := .File.API.Components.SecuritySchemes }}

// {{ pascal $security }}Auth is responsible for extracting "{{$security}}" credentials from a request and calling the
// supplied Authenticator to authenticate
{{ goDoc $value.Value.Description }}
func {{ pascal $security }}Auth(fn {{if eq $value.Value.Scheme "basic"}}Basic{{end}}Authenticator) HttpAuthFunc {
    return func (ctx *fasthttp.RequestCtx) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
    {{- if eq $value.Value.Type "apiKey" }}
        {{- if eq $value.Value.In "query" }}
        key, err := fastutil.QueryString(ctx, "{{$value.Value.Name}}")
        if err != nil {
            return nil, fastutil.ErrUnauthorized
        }
        {{- else if eq $value.Value.In "header" }}
        b := ctx.Request.Header.Peek("{{$value.Value.Name}}")
        if len(b) == 0 {
            return nil, fastutil.ErrUnauthorized
        }

        key := string(b)
        {{- else if eq $value.Value.In "cookie" }}
        b := string(ctx.Request.Header.Cookie("{{$value.Value.Name}}"))
        if len(b) == 0 {
            return nil, fastutil.ErrUnauthorized
        }

        key := string(b)
        {{end}}

        return fn(key)
    {{- else if eq $value.Value.Type "http" }}
        {{- if eq $value.Value.Scheme "bearer" }}
        b := ctx.Request.Header.Peek("Authorization")
        if len(b) == 0 {
            return nil, fastutil.ErrUnauthorized
        }

        // TODO: Option for strict header
        if bytes.HasPrefix(b, bearerAuthPrefix){
            b = b[7:]
        }

        return fn(string(b))
        {{- else if eq $value.Value.Scheme "basic" }}
        b := ctx.Request.Header.Peek("Authorization")
        if len(b) == 0 {
            return nil, fastutil.ErrBasicAuthenticate
        }

        payload, err := base64.StdEncoding.DecodeString(string(b[len(basicAuthPrefix):]))
        if err != nil {
            return nil, fastutil.ErrUnauthorized
        }

        pair := bytes.SplitN(payload, []byte(":"), 2)
        if len(pair) != 2 {
            return nil, fastutil.ErrUnauthorized
        }

        return fn(string(pair[0]),string(pair[1]))
        {{- end }}
    {{- else  }}
        // TODO: Support: {{ toJson $value }}
        return nil, fastutil.ErrUnauthorized
    {{- end }}
    }
}
{{- end }}

{{- if $.HasComplexAuth }}

// Complex Auth Support
{{- if .HasAuthorization -}}
// Scope is the individual security attribute to check for authorization
type Scope = string

// Scopes is the collection
type Scopes = []string

type AuthCheck struct {
    fn HttpAuthFunc
    Scopes
}
{{ else }}
type AuthCheck struct {
    fn HttpAuthFunc
}

{{ end }}
type SecurityGroup map[string]AuthCheck

type SecurityGroups  []SecurityGroup

type AuthResults map[string] *{{ $.CheckPackage $.Params.Auth $packageName }}

func (s SecurityGroup) Add(name string, fn HttpAuthFunc
{{- if .HasAuthorization -}}
, scopes ...string
{{- end -}}
) SecurityGroup{
	s[name] = AuthCheck{ fn: fn
{{- if .HasAuthorization -}}
, Scopes: scopes
{{- end -}}
}

	return s
}

func NewSecurityGroups(groups ...SecurityGroup) SecurityGroups{
	return groups
}

func doAuthorize(ctx *fasthttp.RequestCtx,
{{- if .HasAuthorization -}}
    authorize Authorizer,
{{- end -}}
    groups ...SecurityGroup) (*{{ $.CheckPackage $.Params.Auth $packageName }}, error){

	var user *{{ $.CheckPackage $.Params.Auth $packageName }}
	var err error

	users := AuthResults{}

    authorizeGroup := func (group SecurityGroup)(*{{ $.CheckPackage $.Params.Auth $packageName }}, error){
		for name, check := range group {
			user,ok := users[name]
			if !ok {
				user, err = check.fn(ctx)
				if err != nil {
					return nil, err
				}

				users[name] = user
			}
{{- if .HasAuthorization }}

			if len(check.Scopes) > 0 {
				err = authorize(user, check.Scopes...)
				if err != nil {
					return nil, err
				}
			}
{{ end -}}
		}

		return user, nil
	}

	for _, group := range groups {
		user, err := authorizeGroup(group)
		if err == nil {
			return user, nil
		}
	}

	return nil, err
}

{{- end }}
