// Code generated by foji 0.1, DO NOT EDIT!

package pg

import (
	"context"

	"github.com/pkg/errors"
)

// Table represents a result from 'GetTables'.
type Table struct {
	ID        int64   `json:"id,omitempty"`         // oid
	Schema    string  `json:"schema,omitempty"`     // name
	Name      string  `json:"name,omitempty"`       // name
	Type      *string `json:"type,omitempty"`       // text
	CanUpdate bool    `json:"can_update,omitempty"` // bool
	CanInsert bool    `json:"can_insert,omitempty"` // bool
	CanDelete bool    `json:"can_delete,omitempty"` // bool
	Comment   *string `json:"comment,omitempty"`    // text
}

// GetTables returns Table
//
func (r Repo) GetTables(ctx context.Context) ([]*Table, error) {
	query := `--# GetTables Table
SELECT c.oid                                                        AS id,
       n.nspname                                                    AS schema,
       c.relname                                                    AS name,
       CASE c.relkind
           WHEN 'r' THEN 'table'
           WHEN 'f' THEN 'foreign'
           WHEN 'v' THEN 'view'
           WHEN 's'
               THEN 'special' END                                   AS type,
       (pg_relation_is_updatable(c.oid::regclass, FALSE) & 4) = 4   AS can_update,
       (pg_relation_is_updatable(c.oid::regclass, FALSE) & 8) = 8   AS can_insert,
       (pg_relation_is_updatable(c.oid::regclass, FALSE) & 16) = 16 AS can_delete,
       obj_description(c.oid)                                       AS comment
  FROM pg_class c
       LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
 WHERE c.relkind IN ('r', 'p', 'v', 'f')
   AND n.nspname <> 'pg_catalog'
   AND n.nspname <> 'information_schema'
   AND n.nspname !~ '^pg_toast'
   AND n.nspname !~ '^pg_temp_'
   AND pg_catalog.pg_table_is_visible(c.oid)
 ORDER BY schema, name`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "GetTables.Query")
	}
	var result []*Table
	for q.Next() {
		row := Table{}
		err := q.Scan(&row.ID, &row.Schema, &row.Name, &row.Type, &row.CanUpdate, &row.CanInsert, &row.CanDelete, &row.Comment)
		if err != nil {
			return nil, errors.Wrap(err, "GetTables.scan") // notest
		}
		result = append(result, &row)
	}
	return result, nil

}

// Index represents a result from 'GetIndexes'.
type Index struct {
	ID        int64    `json:"id,omitempty"`         // oid
	Schema    string   `json:"schema,omitempty"`     // name
	Name      string   `json:"name,omitempty"`       // name
	Table     string   `json:"table,omitempty"`      // name
	IsUnique  bool     `json:"is_unique,omitempty"`  // bool
	IsPrimary bool     `json:"is_primary,omitempty"` // bool
	Columns   []string `json:"columns,omitempty"`    // _name
	Comment   *string  `json:"comment,omitempty"`    // text
}

// GetIndexes returns Index
//
func (r Repo) GetIndexes(ctx context.Context) ([]*Index, error) {
	query := `--# GetIndexes Index
SELECT ix.indexrelid                                                                              AS id,
       n.nspname                                                                                  AS schema,
       c.relname                                                                                  AS name,
       t.relname                                                                                  AS table,
       ix.indisunique                                                                             AS is_unique,
       ix.indisprimary                                                                            AS is_primary,
       Array(SELECT attname FROM pg_attribute a WHERE a.attrelid = ix.indexrelid ORDER BY attnum) AS columns,
       obj_description(ix.indexrelid)                                                             AS comment
  FROM pg_index ix
       JOIN pg_class t ON t.oid = ix.indrelid
       JOIN pg_class c ON c.oid = ix.indexrelid
       JOIN pg_namespace AS n
            ON n.oid = c.relnamespace
 WHERE n.nspname NOT IN ('pg_toast', 'pg_temp_1', 'pg_toast_temp_1', 'pg_catalog', 'information_schema')
 ORDER BY t.relname,
          c.relname`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "GetIndexes.Query")
	}
	var result []*Index
	for q.Next() {
		row := Index{}
		err := q.Scan(&row.ID, &row.Schema, &row.Name, &row.Table, &row.IsUnique, &row.IsPrimary, &row.Columns, &row.Comment)
		if err != nil {
			return nil, errors.Wrap(err, "GetIndexes.scan") // notest
		}
		result = append(result, &row)
	}
	return result, nil

}

// Enum represents a result from 'GetEnums'.
type Enum struct {
	ID      int64    `json:"id,omitempty"`      // oid
	Name    string   `json:"name,omitempty"`    // name
	Schema  string   `json:"schema,omitempty"`  // name
	Values  []string `json:"values,omitempty"`  // _name
	Comment *string  `json:"comment,omitempty"` // text
}

// GetEnums returns Enum
//
func (r Repo) GetEnums(ctx context.Context) ([]*Enum, error) {
	query := `--# GetEnums Enum
SELECT t.oid                                                                               AS id,
       t.typname                                                                           AS name,
       n.nspname                                                                           AS schema,
       Array(SELECT enumlabel FROM pg_enum WHERE enumtypid = t.oid ORDER BY enumsortorder) AS values,
       obj_description(t.oid)                                                              AS comment
  FROM pg_type t
       JOIN pg_namespace AS n
            ON n.oid = t.typnamespace
 WHERE t.typtype = 'e'`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "GetEnums.Query")
	}
	var result []*Enum
	for q.Next() {
		row := Enum{}
		err := q.Scan(&row.ID, &row.Name, &row.Schema, &row.Values, &row.Comment)
		if err != nil {
			return nil, errors.Wrap(err, "GetEnums.scan") // notest
		}
		result = append(result, &row)
	}
	return result, nil

}

// ForeignKey represents a result from 'GetForeignKeys'.
type ForeignKey struct {
	ID             int64    `json:"id,omitempty"`              // oid
	Schema         string   `json:"schema,omitempty"`          // name
	Name           string   `json:"name,omitempty"`            // name
	Table          string   `json:"table,omitempty"`           // name
	Columns        []string `json:"columns,omitempty"`         // _name
	ForeignSchema  string   `json:"foreign_schema,omitempty"`  // name
	ForeignTable   string   `json:"foreign_table,omitempty"`   // name
	ForeignColumns []string `json:"foreign_columns,omitempty"` // _name
	Comment        *string  `json:"comment,omitempty"`         // text
}

// GetForeignKeys returns ForeignKey
//
func (r Repo) GetForeignKeys(ctx context.Context) ([]*ForeignKey, error) {
	query := `--# GetForeignKeys ForeignKey
SELECT con.oid                                                                         AS id,
       (SELECT nspname FROM pg_namespace ns WHERE cl.relnamespace = ns.oid)            AS schema,
       conname                                                                         AS name,
       cl.relname                                                                      AS table,
       ARRAY(SELECT attname
               FROM pg_attribute a
              WHERE a.attrelid = con.conrelid
                AND a.attnum = ANY (con.conkey)
              ORDER BY attnum)                                                          AS columns,
       (SELECT nspname FROM pg_namespace ns WHERE foreign_class.relnamespace = ns.oid) AS foreign_schema,
       foreign_class.relname                                                           AS foreign_table,
       ARRAY(SELECT attname
               FROM pg_attribute a
              WHERE a.attrelid = con.confrelid
                AND a.attnum = ANY (con.confkey)
              ORDER BY attnum)                                                          AS foreign_columns,
       obj_description(con.oid)                                                        AS comment
  FROM pg_class cl
       JOIN pg_constraint con ON con.conrelid = cl.oid
       JOIN pg_class foreign_class ON
              foreign_class.oid = con.confrelid`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "GetForeignKeys.Query")
	}
	var result []*ForeignKey
	for q.Next() {
		row := ForeignKey{}
		err := q.Scan(&row.ID, &row.Schema, &row.Name, &row.Table, &row.Columns, &row.ForeignSchema, &row.ForeignTable, &row.ForeignColumns, &row.Comment)
		if err != nil {
			return nil, errors.Wrap(err, "GetForeignKeys.scan") // notest
		}
		result = append(result, &row)
	}
	return result, nil

}

// Column represents a result from 'GetColumns'.
type Column struct {
	Schema     string  `json:"schema,omitempty"`      // name
	Table      string  `json:"table,omitempty"`       // name
	Name       string  `json:"name,omitempty"`        // name
	Ordinal    int32   `json:"ordinal,omitempty"`     // int2
	Nullable   bool    `json:"nullable,omitempty"`    // bool
	HasDefault bool    `json:"has_default,omitempty"` // bool
	Type       string  `json:"type,omitempty"`        // name
	Comment    *string `json:"comment,omitempty"`     // text
}

// GetColumns returns Column
//
func (r Repo) GetColumns(ctx context.Context) ([]*Column, error) {
	query := `--# GetColumns Column
SELECT n.nspname                                          AS schema,
       c.relname                                          AS table,
       a.attname                                          AS name,
       attnum                                             AS ordinal,
       NOT a.attnotnull                                   AS nullable,
       atthasdef                                          AS has_default,
       (SELECT typname FROM pg_type WHERE oid = atttypid) AS type,
       col_description(a.attrelid, a.attnum)              AS comment
  FROM pg_attribute a
       JOIN pg_class c ON attrelid = c.oid AND relkind IN ('v', 'r')
       JOIN pg_namespace n ON c.relnamespace = n.oid AND nspname NOT IN
                                                         ('pg_toast', 'pg_temp_1', 'pg_toast_temp_1', 'pg_catalog',
                                                          'information_schema')
 WHERE a.attnum > 0
 ORDER BY schema, "table", ordinal`
	q, err := r.db.Query(ctx, query)
	if err != nil {
		return nil, errors.Wrap(err, "GetColumns.Query")
	}
	var result []*Column
	for q.Next() {
		row := Column{}
		err := q.Scan(&row.Schema, &row.Table, &row.Name, &row.Ordinal, &row.Nullable, &row.HasDefault, &row.Type, &row.Comment)
		if err != nil {
			return nil, errors.Wrap(err, "GetColumns.scan") // notest
		}
		result = append(result, &row)
	}
	return result, nil

}
